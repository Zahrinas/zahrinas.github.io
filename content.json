{"meta":{"title":"Blog Zahrinii","subtitle":"Zahringenia","description":"","author":"Arraeus Zarius","url":"https://zahrinas.github.io","root":"/"},"pages":[{"title":"分类","date":"2023-10-19T13:47:47.000Z","updated":"2023-10-24T15:51:58.818Z","comments":true,"path":"categories/index.html","permalink":"https://zahrinas.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-24T15:43:15.000Z","updated":"2023-10-24T15:52:26.507Z","comments":true,"path":"tags/index.html","permalink":"https://zahrinas.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"decision procedures notes","slug":"decision-procedures-notes","date":"2023-11-02T15:27:29.000Z","updated":"2023-11-08T06:23:05.657Z","comments":true,"path":"2023/11/02/decision-procedures-notes/","link":"","permalink":"https://zahrinas.github.io/2023/11/02/decision-procedures-notes/","excerpt":"Decision Procedures: An Algorithmic Point of Viewby Daniel Kroening &amp; Ofer Strichman第二版英文版","text":"Decision Procedures: An Algorithmic Point of Viewby Daniel Kroening &amp; Ofer Strichman第二版英文版 1 Introduction and Basic Concepts1.1 Two Approaches to Formal Reasoning两种解决可行性问题的常用途径：证明论proof-theoretic（通过严格的推理）、模型论model-theoretic（通过枚举有限解）。 1.1.1 Proof by Deduction1.1.2 Proof by Enumeration1.1.3 Deduction and Enumeration1.2 Basic Defi nitions过程的可靠性soundness：只有当其返回永真结果时，输入公式永真。过程的完备性completeness：其必然停机，并且对永真式返回永真结果。如果过程既有可靠性又有完备性，称为决策过程decision procedure。称一个理论是可决定decidable的，当且仅当该理论存在一个决策过程。 1.3 Normal Forms and Some of Their Properties两个公式是等价可满足equisatis able的，意即它们都是可满足的，或都是不可满足的。这个概念将被用在范式转换中。否定范式negation normal form：只含$\\neg, \\wedge, \\vee$联结词，且只在原子公式上应用$\\neg$。原子公式及其否定被称为字面值literal，并分别对应正positive和负negative。在NNF公式中，叠加的后一性质也称为原子公式的极性polarity或相位phase，如$\\neg \\neg \\neg x_1$是负的。NNF的单调性：增加一个赋值所满足的字面值数量，公式的可满足性仍然保持（但并不保持不可满足性）。析取范式disjunctive normal form和合取范式conjunctive normal form都是NNF。Tseitin编码：在公式中添加线性个数的原子公式和约束，其中每个原子公式等价于一个联结词的结果，就能在线性范围内把公式写成CNF。等价关系可以只写成保持原子公式蕴含联结词结果即可。一些对Tseitin的优化。连续的合取或析取联结词只需要写成一个原子公式；由于单调性，有一些子句可以安全地被忽略。 1.4 The Theoretical Point of View非逻辑符号（常量，函数）的集合称为签名signature。没有自由变量的公式称为句sentence。限制逻辑联结词的理论被称为理论的片fragment。 1.4.1 The Problem We Solve1.4.2 Our Presentation of Theories1.5 Expressiveness vs. Decidability理论可以被认为是语言language，公式即是其词。称$A$理论比$B$理论表达力强more expressive，若$B$理论的所有公式均能由$A$理论定义，但$A$理论中存在公式不能由$B$理论定义，记作$B \\prec A$。 1.6 Boolean Structure in Decision Problems1.7 Logic as a Modeling Language2 Decision Procedures for Propositional Logic2.1 Propositional Logic2.1.1 Motivation2.2 SAT Solvers2.2.1 The Progress of SAT SolvingSAT减少搜索空间的两个重要路径：从错误中学习、对能减少问题规模的关键变量尽早赋值。SAT主要可分为两类。冲突驱动子句学习Conflict-Driven Clause Learning，基于DPLL发展而来；随机搜索stochastic search，贪心调整所猜测的赋值。显然CDCL比随机搜索更系统化。 2.2.2 The CDCL FrameworkCDCL框架下，对一个CNF子句有以下四种分类：满足satisfied：有字面量被满足；冲突conflicting：所有字面量都被赋值但不满足；单元unit：未满足，但除去一项以外都已赋值；未解：其他情况。单元子句规则unit clause rule。如果一个子句是单元的，则其未赋值的一项为真。这个字句称为其前导子句antecedent clause。 2.2.3 BCP and the Implication GraphCDCL-SAT算法框架：给字面量赋值被称为决定decision，每个决定都有一个决定等级decision level。有标签的有向无环图$G(V, E)$为影响图implication graph，其中：$V$是赋值的字面量，标签为其决定等级。此外，还有一个特殊冲突节点$\\kappa$；$E$是单元字句规则中，前提字面量到推知字面量的有向边，标签为前导子句，除由某无法满足的子句中的所有字面量引到$\\kappa$，标签为该子句。部分影响图partial implication graph代表一个决定等级，如：也就是布尔变量传播Boolean Constraint Propagation过程。一旦遇到冲突，CDCL学习冲突，生成一个冲突子句conflict clause，然后回到与此冲突有关的倒数第二个决定等级，即抹去该等级后的所有决定，以便于立刻推知一个相关变量。特殊情况：如果生成的冲突子句是一元子句，则回到等级0；如果已经在等级0，整个CNF就是不可解的。这个过程在ANALYZE-CONFLICT()中实现。算法的完备性基于搜索，显然。可靠性由每次到达同一决定等级时赋值情况一定不同来保证。 2.2.4 Conflict Clauses and Resolution冲突的唯一影响点unique implication point：影响图中，能割掉决定点和$\\kappa$的连通性的割点。注意到决定点是最远的UIP。首个UIP（离$\\kappa$最近的唯一影响点）用来生成冲突子句；它能覆盖之前所有的UIP，并且便于恢复到更低的决定等级。当决定等级$5$、赋值顺序是$x_4, x_5, x_6, x_7$时，一个冲突子句$c_5$应当根据倒序遍历到首个UIP（$x_4@5$）生成。这个过程实现于下述ANALYZE-CONFLICT()函数框架：在此例中： 2.2.5 Decision Heuristics决定启发decision heuristic过程决定如何高效选择赋值顺序和赋值。如下是一些简单的决定启发方法。Jeroslow-Wang：对每个子句集$\\mathcal{B}$中的字面量$l$计算一个权重$$J(l)&#x3D;\\sum_{\\omega \\in \\mathcal{B},l \\in \\omega}2^{-|\\omega|},$$其中$\\omega$是子句，$|\\omega|$为其长度。选择权重最高的未决定变量赋值。其期望通过一个赋值尽可能生成更多短子句。Dynamic Largest Individual Sum (DLIS)：选取能满足最多子句的赋值。Variable State Independent Decaying Sum (VSIDS)：计算每个变量出现的子句数作为权重，周期性地把这个权重除以2。注意到新添加的冲突子句的权重比之前的子句高，所以这个方法诱导尽快满足冲突子句中的变量。其一个变体给推出冲突子句的子句变量增加随时间递增的权重。Berkmin：计算每个变量出现的子句数作为权重，把生成的冲突子句压进栈。每次在栈顶选一个最高权的字面量按照其他子句中的出现情况（正或负）贪心赋值。Clause-Move-To-Front (CMTF)：把每个冲突的原因子句和冲突按序压进栈，期望在避免冲突后再次搜索原因子句，以让搜索更加内聚。 2.2.6 The Resolution Graph and the Unsatisfiable Core定义一种归结图resolution graph，用以验证算法结果。二叉归结图：根节点为原问题子句，其他节点由其二值归结前件的两个节点引边。超归结图：根节点为原问题子句，其他节点由其任何归结前件的节点，也即二叉归结图中的多层父节点，引边。这种图可以用来演算不满足核unsatisfiable core，即互相冲突的子句集合，便于改进问题。满足结果代值即可证明。通过验证归结图的产生，可以检验不满足结果。 2.2.7 Incremental Satisfiability理论上，如果一个问题$C_2$由问题$C_1$添加删除子句修改而来，可以沿用前一个问题的求解中间结果，如启发参数。假定assumptions机制：添加一些在$C_1$中保持的字面量，但在$C_2$中可能不存在或预设其取反。如果求解器回溯到假定的决定等级之下，则可认为问题无解（相当于新问题中取到负决定等级）。这是因为冲突子句生成过程与字面量取值无关。对于在$C_1$的基础上求解$C_2$，$C_2 \\setminus C_1$直接加到子句集中。$C_1 \\setminus C_2$的处理是，让$C_1$的子句$c$替换成新的子句$\\neg a \\vee c$，并假定$a$为真，在$C_2$中添加$\\neg a \\vee c$，并假定$a$为假。 2.2.8 From SAT to the Constraint Satisfaction Problem约束满足问题Constraint Satisfaction Problem含有谓词以及变量定义域。是NP问题，可以在多项式时间内规约到SAT。约束的传播器propagator：根据谓词属性压缩变量的定义域。传播器一般是可靠的，但不一定完善。 2.2.9 SAT Solvers: Summary","categories":[{"name":"学术学习","slug":"学术学习","permalink":"https://zahrinas.github.io/categories/%E5%AD%A6%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Introduction to Modern Cryptography - Notes","slug":"introduction-to-modern-cryptography-notes","date":"2023-10-20T05:44:07.000Z","updated":"2023-11-02T15:26:34.143Z","comments":true,"path":"2023/10/20/introduction-to-modern-cryptography-notes/","link":"","permalink":"https://zahrinas.github.io/2023/10/20/introduction-to-modern-cryptography-notes/","excerpt":"Introduction to Modern Cryptographyby Jonathan Katz &amp; Yehuda Lindell主用第二版中文版，并参第三版英文版","text":"Introduction to Modern Cryptographyby Jonathan Katz &amp; Yehuda Lindell主用第二版中文版，并参第三版英文版 1 概论1.1 密码学和现代密码学1.2 对称密钥加密的基本设置对称密钥方法：双方能够用秘密方式共享一个密钥对称密钥方案的三个算法：$Gen()$得到密钥$k$，$Enc_k(m)$得到密文$c$，$Dec_k(c)$得到明文$m$。所有密钥的集合成为密钥空间$\\mathbb{K}$，所有合法明文成为明文空间$\\mathbb{M}$，从两者可以定义密文空间$\\mathbb{C}$。一个加密方案通过定义三个算法和$\\mathbb{M}$来完全定义。基本要求：$Dec_k(Enc_k(m))=m$。柯克霍夫原则：所有算法细节都可公开。安全性只依赖于密钥的安全性。攻击场景：唯有密文（最常见）、已知明文（得到部分对应关系）、选择明文（能够从任意输入得到$Enc_k()$的输出）、选择密文（能够从任意输入得到$Dec_k()$的输出）。 1.3 古典加密术及其密码分析对加密方案应用柯克霍夫原则进行分析。凯撒密码和移位密码：密钥空间太小，容易穷举破解。启发：密钥空间充分性原则——密钥空间必须能够抵抗穷举搜索，除非应用场景下消息空间更小。单字母替换：密钥空间大；但保持统计信息，容易分析破解。Vigenere加密：用一个短密钥，对明文中每一小段进行按位移位。其破解。当密钥长度已知显然破解简单。密钥长度可以通过观察重复模式和遍历密钥长度并比对相同位置字符的统计分布得到。启发：复杂性并不意味着安全性。 1.4 现代密码学的基本原则形式化定义是困难的。一个比较完整的定义：攻击者不能从密文中计算关于明文的任何函数（语义和统计规律？）。通用的安全定义：有特定能力的攻击者不能完成特定的攻破。现代研究中常用的规约方法。考虑假设$X$为真，可以构建系统$Y$为安全。通过攻破系统$Y$，可以证明假设$X$不为真。 2 完善保密加密2.1 定义和基本属性注意对一个明文，加密算法可能给出多种密文。（单射。）完善保密加密的定义：攻击者接收密文前后，所知明文发送的概率不变，也即密文没有泄露任何有关明文在明文空间中选取的信息。即$P[M=m|C=c]=P[M=m]$（后验概率等于先验概率）。一个等价表述是$P[C=c|M=m]=P[C=c]$（称完美不可区分性）。思想实验。加密者从两个明文中选出一个，令无任何能力限制的攻击者猜测密文对应的明文。如概率收敛到$\\frac{1}{2}$，则称敌手不可区分性。与上述两个概念等价。 2.2 一次一密（Vernam加密）生成密钥$k$为某长度的01串。$m$为同长度的01串，$c=m\\oplus k$。该加密方案是完善保密加密的。缺陷一。密钥、明文、密文为相同长度，以至于首先必须安全存储密钥。缺陷二。一个密钥只能使用一次，否则（举例来说）就能够得出两个明文间的异或关系。 2.3 完善保密的局限完善保密加密最基本的需求是密钥空间大于等于明文空间。证明。采用反证。如若密钥空间小于明文空间，给定密文$c$，其可能明文有$|\\mathbb{K}|&lt;|\\mathbb{M}|$个,则必定存在$m \\in \\mathbb{M}$使$P[M=m|C=c]=0≠P[M=m]$。 2.4* 香农定理香农定理。对一个$|\\mathbb{K}|=|\\mathbb{M}|=|\\mathbb{C}|$的加密方案，当且仅当以下条件成立，为完善保密加密。 $Gen()$产生任何密钥概率相等。 对任意$m$和$c$，存在唯一$k$为正确密钥。 证明。充分性。对任意$c$，所有$m \\in \\mathbb{M}$都取到一个$k \\in \\mathbb{K}$。当密钥概率相等，易知$P[M=m|C=c]=P[M=m]$。必要性。完善保密加密下，对任意$m$，所有$k \\in \\mathbb{K}$一一对应所有$c \\in \\mathbb{C}$（否则不能双射，显然违反等概率）。此时对所有$k$的选取概率必然有$P[K=k]=P[C=c]=P[C=c|M=m]$。 2.5 小结3 对称密钥加密以及伪随机性3.1 密码学的计算方法信息理论安全或称完美安全，是指攻击者计算能力无限的情况下也不能攻破。例如上述完善保密加密。计算安全比信息理论安全弱，目的是在有限计算能力下的安全。注意到其必然引入一些假设，尤其是$P≠NP$。计算安全所定义的特定能力：较长时间的现代计算机使用。特定攻破：低于一个极小概率的破译。","categories":[{"name":"学术学习","slug":"学术学习","permalink":"https://zahrinas.github.io/categories/%E5%AD%A6%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"数理逻辑 笔记","slug":"shuli-luoji-notes","date":"2023-10-19T13:36:28.000Z","updated":"2023-11-02T15:26:12.194Z","comments":true,"path":"2023/10/19/shuli-luoji-notes/","link":"","permalink":"https://zahrinas.github.io/2023/10/19/shuli-luoji-notes/","excerpt":"数理逻辑by 汪芳庭主用第二版","text":"数理逻辑by 汪芳庭主用第二版 0 预备知识0.1 集论初等概念一些以前不常见到的记号。幂集$\\mathcal{P}(A)={a|a \\subseteq A}$。积集$A \\times B={(a, b)|a \\in A, b \\in B}$，规定$A^0=\\emptyset$。如若$R \\subseteq A \\times B$，称$R$是$A$到$B$的关系。若$R \\subseteq A^n$，称$R$是$A$上的$n$元关系。一元关系即子集。等价类满足自反、对称和传递性。$a$与$b$等价记作$a \\sim b$。$a$在某等价关系上形成的等价类记作$[a]$。对$A$上的等价关系$R$，所有$R$等价类的集称为商集，记作$A/R$。对一个映射关系$f:X \\rightarrow Y$，若有$(x_0,y_0) \\in f$，则$y_0$称为$x_0$的象，反过来称为原象，写作$x_0 \\mapsto y_0$或$y_0=f(x_0)$。$f:A^n \\rightarrow A$称为$A$上的$n$元运算。 0.2 Peano自然数公理皮亚诺自然数公理： $0$是自然数。 任何自然数有唯一后继。 任何自然数后继不为$0$。 不同自然数的后继不同。 当$0 \\in M$，并且$x \\in M$时$x$的后继$x’ \\in M$，则$M$是自然数集。 把$0$的后继记为$1$，以此类推，即是一般意义上的自然数集。$f: N^k \\rightarrow N$称为$k$元数论函数。已知$k$元数论函数$g$和$k+2$元数论函数$h$，当f(n_1,...,n_k,0)=g(n_1,...,n_k),$$$$f(n_1,...,n_k,n+1)=h(n_1,...,n_k,n,f(n)),此时唯一存在$k+1$元数论函数$f$是递归函数。当$k=0$可做如下定义。已知常数$m$和二元数论函数$h$，当$f(0)=m$，$f(n+1)=h(n,f(n))$，称f是由$m$和$h$递归定义的函数。 0.3 可数集由可数集的元素构造的有序有限元组的集也是可数集。证明考虑映射到素数无穷。 1 命题演算1.1 命题联结词与真值表1.2 命题演算的建立1.2.1 命题演算公式集注意我们把命题演算建立在唯二联结词$\\neg$和$\\rightarrow$的基础上。公式。命题变元$p,q$是公式，那么$\\neg p, p \\rightarrow q$是公式。由此可得公式集$L(X)$，其中L_0=X={x_1, x_2, ..., x_n, ...}, L_1={\\neg x_1, \\neg x_2, ..., \\neg x_n, ..., x_1 \\rightarrow x_1, x_1 \\rightarrow x_2, ..., x_i \\rightarrow x_j, ...},以此类推。这称为公式集的分层性，即各层互不相交。显然可见L(X)是可数的。推广，由有限命题变元$X_n={x_1, …, x_n}$构成的公式集$L(X_n)$也具有分层性和可数性。 1.2附1 命题演算公式的唯一读法判断一个字串是公式，采用构造方式：先写成前置式（$\\rightarrow pq$）。为每个字符赋予权$w(\\neg)=0, w(\\rightarrow)=-1, w(x_i)=1$。若一字串是公式，则其总权重为$1$，且除自身的前缀子串总权重均小于$1$。由此可推知一个字串如果由两个公式并接而成，则并接方式唯一。（采用反证法，一个公式不能是另一个公式的真前缀子串。） 1.2附2 命题演算公式集的代数结构公式集的归纳定义： L_0=X,$$$$L_k=(\\{\\neg\\} \\times L_{k-1}) \\cup (\\bigcup_{i+j=k-1} \\{\\rightarrow\\} \\times L_i \\times L_j), k>0,$$$$L(X)=\\bigcup_{k=0}^\\infty L_k.1.2.2 命题演算$L$","categories":[{"name":"学术学习","slug":"学术学习","permalink":"https://zahrinas.github.io/categories/%E5%AD%A6%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[]}],"categories":[{"name":"学术学习","slug":"学术学习","permalink":"https://zahrinas.github.io/categories/%E5%AD%A6%E6%9C%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[]}